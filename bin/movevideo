w#!/usr/bin/env ruby
#
#  Created by Paul McKibbin on 2006-11-05.
#  Copyright (c) 2006-2012. All rights reserved.
$:.unshift(File.join(File.dirname(__FILE__),'..','lib','config'))
LOG_DIR='/var/log/borg'
LOG_FILE='movevideo.log'
require 'rubygems'
require "logger"
require 'fileutils'
require 'Config'
require 'Filename'

class TVMover
  include Config
  config :borg_params

  def initialize(filename)
    Log.info { "Analysing #{filename}." }
    @filename=filename
    @year, @series_name, @season, @episode, @title=Filename::location(filename)
  end

  def for_all_destinations(&blk)
    self.class.borg_params[:destinations].each do |directory|
      yield directory
    end
  end

  def first_destination_matching(*arr)
    for_all_destinations do |directory|
      dir_to_check=File.join(directory,arr)
      return dir_to_check if File.exists?(dir_to_check)
    end
    nil
  end

  def series_directory
    first_destination_matching(@series_name)
  end

  def series_in_year
    first_destination_matching(@year.to_s,@series_name)
  end

  def broadcast_year
    first_destination_matching(@year.to_s)
  end

  def default_directory
    root=first_destination_matching
    root && File.join(root,@series_name)
  end

  def actual_directory
    #series_directory || series_in_year || broadcast_year || default_directory
    series_directory || default_directory
  end

  def destination_directory
    @destination_directory||=actual_directory
  end

  def pad_integer(value)
    begin
      "%02d" % value.to_i
    rescue
      "00"
    end
  end

  def season
    pad_integer(@season)
  end

  def episode
    pad_integer(@episode)
  end

  def move
    if @year || (try_directory_name && @year)
      location=@episode.nil? ? destination_directory : File.join(destination_directory, "Season#{season}")
      move_to(File.join(location, "#{@series_name}_#{season}x#{episode}_#{@title}")) if create_directory(location)
    else
      Log.error{"Unable to determine series details for #{@filename}."}
    end
  end

  def try_directory_name
    extension=File.extname(@filename)
    file_parts=@filename.split(/\//)
    filename=File.join(file_parts[0..-2],"#{file_parts[-2]}#{extension}")
    @year, @series_name, @season, @episode, @title=Filename::location(filename)
  end

  def touch_tree(series_dirname)
    tree=series_dirname.split('/')
    parts=tree.size-1
    parts.times do |count|
      file_dirname=File.join(tree[0..count+1])
      FileUtils.touch(file_dirname)
    end
  end

  def create_directory(series_dirname)
    unless File.exists?(series_dirname)
      Log.debug{"Creating series directory #{series_dirname}."}
      begin
        FileUtils.mkdir_p(series_dirname)
      rescue
        Log.error{"Failed to create series directory #{series_dirname}."}
        return false
      end
    else
      Log.debug{"Series directory #{series_dirname} already exists."}
    end
    true
  end

  def move_to(destination)
    unless File.exists?(destination)
      Log.info{"Moving #{@filename} to #{destination}."}
      FileUtils.mv(@filename,destination)
      touch_tree(destination)
    else
      Log.error{"#{destination} already exists. Not moving #{@filename}."}
    end
  end

  def self.find_incoming(filename)
    borg_params[:incoming].each do |incoming_dir|
      return File.join(incoming_dir,filename) if File.exists?(File.join(incoming_dir,filename))
    end
    filename
  end
end

begin
  FileUtils.mkdir_p(LOG_DIR) unless File.exists?(LOG_DIR)
  logfile=File.join(LOG_DIR,LOG_FILE)
  Log=Logger.new(logfile, shift_age='weekly')
rescue => e
  Log=Logger.new(STDOUT)
  Log.error {e.message + ". Logging to stdout."}
end
Log.info {"#{$0} starting."}

if ARGV.empty?
  Log.error {"No files specified. Exiting."}
else
  ARGV.each do |y|
    Dir.glob(y.gsub(/\[/,'\[').gsub(/\]/,'\]')).each do |x|
      filename=x.chomp
      filename=TVMover.find_incoming(filename) unless File.exists?(filename)
      next if File.directory?(filename)
      if File.exists?(filename) then
        TVMover.new(filename).move
      else
        Log.error { "Unable to find file #{filename}." }
      end
    end
  end
end
Log.info {"#{$0} completed."}
